<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dictionary (Plural Forming)</title>
  <style>
    :root{--black:#000;--text:#1a1a1a;--muted:#8a8a8a;--faint:#b5b5b5;--fainter:#d1d1d1;--sep:#f3f3f3;--border:#e3e3e3;--bg:#fff;}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);background:var(--bg);}
    .wrap{max-width:1180px;margin:0 auto;padding:24px}

    header{display:flex;align-items:center;justify-content:flex-end;padding:6px 0 10px;border-bottom:2px solid #ebebeb}
    header .menu{width:36px;height:36px;border:0;background:transparent;display:grid;place-items:center;cursor:pointer}
    .burger{width:22px;height:14px;position:relative}
    .burger::before,.burger::after,.burger span{content:"";position:absolute;left:0;right:0;height:2px;background:#000;border-radius:2px}
    .burger::before{top:0} .burger span{top:6px} .burger::after{bottom:0}

    .grid{display:grid;grid-template-columns:1fr 420px;gap:28px;padding-top:18px}

    .searchRow{display:flex;align-items:flex-end;gap:14px}
    .inputWrap{flex:1;min-width:220px;position:relative;padding-bottom:10px}
    input[type="text"]{width:100%;border:0;outline:none;font-size:22px;padding:0;background:transparent;color:#000}
    input::placeholder{color:#bdbdbd}
    .underline{position:absolute;left:0;right:0;bottom:0;height:4px;background:#000;border-radius:2px}

    .dir{display:flex;align-items:center;gap:8px;padding-bottom:6px;user-select:none}
    .dir button{
      border:1px solid #e6e6e6;border-bottom-width:2px;
      background:#fff;color:#666;border-radius:999px;
      padding:6px 10px;font-size:12px;cursor:pointer;
    }
    .dir button[data-active="true"]{color:#111;border-color:#dcdcdc;background:#fafafa}

    .suggestList{margin:14px 0 0 0;padding:0;list-style:none}
    .suggestItem{display:flex;align-items:baseline;justify-content:space-between;gap:16px;padding:12px 0;border-top:2px solid var(--sep);cursor:pointer}
    .suggestItem:first-child{border-top:0}
    .suggestItem .hw{font-size:18px;color:var(--faint)}
    .suggestItem .tr{font-size:18px;color:var(--fainter);text-align:right;min-width:120px}
    .suggestItem[data-active="true"]{background:#fafafa;border-radius:10px;padding-left:10px;padding-right:10px}
    .suggestItem[data-active="true"] .hw{color:#666}
    .suggestItem[data-active="true"] .tr{color:#7a7a7a}

    .detail{
      border:2px solid var(--border);
      border-radius:16px;
      padding:18px;
      height:calc(100vh - 120px);
      max-height:720px;
      overflow:auto;
      overflow-x:hidden;
      position:sticky;
      top:20px;
      background:#fff;
      scrollbar-gutter: stable;
    }

    /* ‚úÖ image block (above word) */
    .imgWrap{
      width:100%;
      border:1px solid var(--sep);
      border-bottom-width:2px;
      border-radius:14px;
      background:#fff;
      overflow:hidden;
      margin:2px 0 12px;
    }
    .entryImg{
      display:block;
      width:100%;
      height:auto;
      max-height:210px;     /* keeps it small */
      object-fit:contain;   /* no cropping */
      background:#fff;
    }

    .wordRow{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap:6px;
    }

    .wordLine{
      display:flex;
      align-items:flex-end;
      gap:10px;
      width:100%;
      max-width:100%;
    }

    .word{
      font-size:40px;
      font-weight:800;
      margin:4px 0 6px;
      color:#000;
      letter-spacing:.2px;
      max-width:100%;
      white-space:nowrap;
      line-height:1.05;
    }

    .word.der{color:#1f6feb;}
    .word.die{color:#d1242f;}
    .word.das{color:#2da44e;}

    .plTag{
      font-size:14px;
      color:var(--muted);
      border:1px solid #eee;
      border-bottom-width:2px;
      background:#fff;
      border-radius:999px;
      padding:4px 10px;
      font-weight:700;
      margin-top:2px;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .plEmpty{visibility:hidden}

    .plHi{color:#7c3aed;font-weight:800;}

    .meta{color:var(--faint);font-size:14px;margin-bottom:10px;line-height:1.35}
    .wordUnderline{height:4px;width:160px;background:#000;border-radius:2px;margin:10px 0 12px}

    .quick{font-size:18px;font-weight:650;color:#111;margin:0 0 14px;line-height:1.35;}

    .explain{font-size:18px;line-height:1.6;color:var(--text)}
    .explain .sense{margin:14px 0 16px}
    .explain .head{font-size:18px;font-weight:800;margin:0 0 8px 0}
    .explain .plain{margin:8px 0 10px;color:#222}
    .explain .pair{
      margin:8px 0;
      padding:10px 12px;
      border:1px solid var(--sep);
      border-bottom-width:2px;
      border-radius:12px;
      background:#fcfcfc;
      display:flex;
      align-items:flex-start;
      gap:10px;
    }

    .explain .langTag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      min-width:auto;
      font-weight:800;
      font-size:12px;
      letter-spacing:.3px;
      padding:3px 10px;
      border-radius:999px;
      border:1px solid #e7e7e7;
      border-bottom-width:2px;
      margin-right:0;
      vertical-align:top;
      line-height:1;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .explain .langTag .flag{font-size:14px; line-height:1;}
    .explain .langTag .code{font-size:11px; opacity:.75; letter-spacing:.6px;}

    .explain .langTag.de{background:#f3f7ff}
    .explain .langTag.sr{background:#fff6f3}
    .explain .langTxt{display:inline; color:#222}

    .pairMain{
      display:flex;
      align-items:flex-start;
      gap:10px;
      flex:1 1 auto;
      min-width:0;
    }

    .art{font-weight:700}
    .art.der{color:#1f6feb;}
    .art.die{color:#d1242f;}
    .art.das{color:#2da44e;}
    .meta .art{font-weight:700}

    .keys{margin-top:10px;color:var(--fainter);font-size:12px;user-select:none}
    kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px;border:1px solid #e6e6e6;border-bottom-width:2px;border-radius:6px;padding:2px 6px;background:#fff;color:#777}

    .err{margin-top:10px;color:#b00020;font-size:12px;display:none}
    .loading{margin-top:10px;color:#c9c9c9;font-size:12px;display:none}

    .speakBtn{
      border:1px solid #e7e7e7;
      border-bottom-width:2px;
      background:#fff;
      border-radius:999px;
      padding:4px 8px;
      font-size:14px;
      line-height:1;
      cursor:pointer;
      user-select:none;
      color:#444;
      flex:0 0 auto;
    }
    .speakBtn:hover{background:#fafafa}
    .speakBtn:active{transform:translateY(1px)}
    .speakBtn[disabled]{opacity:.45; cursor:not-allowed}
    .pair .speakBtn{padding:3px 7px;font-size:13px;margin-left:auto}

    @media (max-width:920px){
      .grid{grid-template-columns:1fr}
      .detail{position:relative;top:auto;height:auto;max-height:none}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <button class="menu" aria-label="Menu" title="Menu"><div class="burger"><span></span></div></button>
    </header>

    <div class="grid">
      <section>
        <div class="searchRow">
          <div class="inputWrap">
            <input id="q" type="text" autocomplete="off" spellcheck="false" placeholder="Search" />
            <div class="underline"></div>
          </div>

          <div class="dir" aria-label="Direction">
            <button id="btnSRDE" data-active="true" title="Serbian ‚Üí German">SR‚ÜíDE</button>
            <button id="btnDESR" data-active="false" title="German ‚Üí Serbian">DE‚ÜíSR</button>
          </div>
        </div>

        <ul id="list" class="suggestList"></ul>
        <div class="loading" id="loading">Loading‚Ä¶</div>
        <div class="err" id="err"></div>
        <div class="keys"><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>Enter</kbd> <kbd>Esc</kbd></div>
      </section>

      <aside class="detail" id="detail"></aside>
    </div>
  </div>

<script>
  const q = document.getElementById("q");
  const list = document.getElementById("list");
  const detail = document.getElementById("detail");
  const btnSRDE = document.getElementById("btnSRDE");
  const btnDESR = document.getElementById("btnDESR");
  const errBox = document.getElementById("err");
  const loading = document.getElementById("loading");

  let dir = "SR_DE";
  let results = [];
  let active = 0;

  function setDir(next){
    dir = next;
    btnSRDE.dataset.active = (dir==="SR_DE") ? "true" : "false";
    btnDESR.dataset.active = (dir==="DE_SR") ? "true" : "false";
    search();
    q.focus();
  }

  btnSRDE.addEventListener("click", ()=> setDir("SR_DE"));
  btnDESR.addEventListener("click", ()=> setDir("DE_SR"));

  function escapeHtml(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function escapeRegExp(s){
    return (s ?? "").toString().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function normalizeCmp(s){
    return (s ?? "").toString()
      .replace(/\s+/g," ")
      .trim()
      .toLowerCase()
      .replace(/[.,;:!?\-‚Äì‚Äî]+$/,"");
  }

  function normalizeGloss(s){
    const t = (s ?? "").toString().trim();
    return t.replace(/^\((der|die|das)\)\s+/i, (_, art) => art.toLowerCase() + " ");
  }

  function getQuickGloss(item){
    const mg = normalizeGloss(item?.main_gloss ?? "").trim();
    if(!mg) return "";
    const first = mg.split(/[;,]/)[0].trim();
    return first || mg;
  }

  function getExplanationText(item){
    const rc = (item?.raw_clean ?? "").toString().trim();
    if(rc) return rc;
    const mg = (item?.main_gloss ?? "").toString().trim();
    if(mg) return mg;
    return "";
  }

  // ‚úÖ image renderer (shows only if image_url exists)
  function renderImageHtml(item){
    const url = (item?.image_url ?? "").toString().trim();
    if(!url) return "";
    return `
      <div class="imgWrap">
        <img class="entryImg"
             src="${escapeHtml(url)}"
             alt=""
             loading="lazy"
             onerror="this.closest('.imgWrap').style.display='none';" />
      </div>
    `;
  }

  // ‚úÖ FIX: remove "abazur (noun, m)" / "aba≈æur (noun, m)" header line even if followed by ¬∂
  function stripRawCleanHeaderLine(rawText, item){
    const t = (rawText ?? "").toString().replace(/\r\n/g, "\n");
    const hw = (item?.headword ?? "").toString().trim();
    const pos = (item?.pos ?? "").toString().trim();
    if(!t || !hw || !pos) return t;

    const hwAscii = hw
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .trim();

    const hwAlt = (hwAscii && hwAscii.toLowerCase() !== hw.toLowerCase())
      ? `(?:${escapeRegExp(hw)}|${escapeRegExp(hwAscii)})`
      : escapeRegExp(hw);

    const re = new RegExp(
      "^\\s*" + hwAlt +
      "\\s*\\(\\s*" + escapeRegExp(pos) +
      "(?:\\s*,\\s*[^)]*)?\\s*\\)\\s*" +
      "(?:\\(\\s*(?:der|die|das)\\s*\\)|\\[\\s*(?:der|die|das)\\s*\\])?\\s*" +
      "(?:\\n+|¬∂+)",
      "i"
    );

    return t.replace(re, "").trim();
  }

  function isDashOnlyLine(s){
    const t = (s ?? "").toString().trim();
    return t === "-" || t === "‚Äì" || t === "‚Äî";
  }

  function normalizeRawLines(text){
    const lines = (text ?? "").toString().replace(/\r\n/g, "\n").split("\n");
    const out = [];

    for(let line of lines){
      if(line == null) continue;
      let s = String(line).replace(/\s+$/,"");
      if(s.trim()==="") continue;
      if(isDashOnlyLine(s)) continue;

      s = s.replace(/^\s*[-‚Äì‚Äî]\s*(DE|SR)\s*:\s*/i, (_, tag) => tag.toUpperCase() + ": ");
      s = s.replace(/^\s*[-‚Äì‚Äî]\s+/,"");
      s = s.replace(/^\s*\d+\.\s+/, "");

      if(s.trim()==="") continue;

      {
        const m = s.match(/^(.*?)(?:\s*\/\s*SR\s*:\s*)(.+)$/i);
        if (m) {
          const left = (m[1] || "").trim();
          const right = (m[2] || "").trim();
          if (left) out.push(`DE: ${left}`);
          if (right) out.push(`SR: ${right}`);
          continue;
        }
      }

      out.push(s);
    }

    return out;
  }

  function dropLeadingQuickDuplicate(lines, quick){
    const qn = normalizeCmp(quick);
    if(!qn) return lines;

    const out = [...lines];
    for(let i=0;i<out.length;i++){
      if(out[i].trim()==="") continue;
      if(normalizeCmp(out[i]) === qn){
        out.splice(i,1);
      }
      break;
    }
    return out;
  }

  function splitIntoSenses(lines){
    const joined = lines.join("\n");
    if(!/\n?\s*\d+[\)\.]\s+/.test(joined)) return [lines];

    const t = joined.replace(/(\s)(\d+[\)\.])\s+/g, "\n$2 ");

    const parts = t.split(/(?=(?:^|\n)\s*\d+[\)\.]\s*)/m)
      .map(s => s.trim())
      .filter(Boolean);

    return parts.map(p => {
      const cleaned = p.replace(/^\s*\d+[\)\.]\s*/,"");
      return normalizeRawLines(cleaned);
    });
  }

  function lineIsLang(line){
    return /^\s*(DE|SR)\s*:\s*/i.test(line || "");
  }

  function splitInlinePair(line){
    const s = (line ?? "").toString().trim();
    if(!s) return null;

    const m = s.match(/^(.*?)(?:\s+[‚Äî‚Äì]\s+)(.*)$/);
    if(!m) return null;

    const left = (m[1] || "").trim();
    const right = (m[2] || "").trim();
    if(!left || !right) return null;
    if(left.length <= 3) return null;

    return { de: left, sr: right };
  }

  function langBadgeHtml(lang){
    const L = (lang || "").toLowerCase();
    const flag = (L === "de") ? "üá©üá™" : "üá∑üá∏";
    const code = (L === "de") ? "DE" : "SR";
    return `<span class="flag" aria-hidden="true">${flag}</span><span class="code">${code}</span>`;
  }

  // -------------------------
  // Speech (ONLY German enabled)
  // -------------------------
  const TTS = {
    voices: [],
    supported: ("speechSynthesis" in window) && ("SpeechSynthesisUtterance" in window),
    currentKey: "",
    speaking: false
  };

  function loadVoices(){
    if(!TTS.supported) return;
    TTS.voices = window.speechSynthesis.getVoices() || [];
  }

  if(TTS.supported){
    loadVoices();
    window.speechSynthesis.onvoiceschanged = () => loadVoices();
  }

  function pickVoice(langTag){
    if(!TTS.supported) return null;
    const want = (langTag || "").toLowerCase();

    let v = TTS.voices.find(x => (x.lang || "").toLowerCase() === want);
    if(v) return v;

    const pref = want.split("-")[0];
    v = TTS.voices.find(x => (x.lang || "").toLowerCase().startsWith(pref));
    if(v) return v;

    return null;
  }

  function normalizeTtsText(s){
    return (s ?? "").toString().replace(/\s+/g, " ").trim();
  }

  function speakText(text, langTag){
    const t = normalizeTtsText(text);
    if(!t) return;
    if(!TTS.supported) return;

    const lang = (langTag || "").toLowerCase();
    if(!(lang.startsWith("de"))) return;

    const key = (langTag || "") + "|" + t;

    if(TTS.speaking && TTS.currentKey === key){
      window.speechSynthesis.cancel();
      TTS.speaking = false;
      TTS.currentKey = "";
      return;
    }

    window.speechSynthesis.cancel();

    const u = new SpeechSynthesisUtterance(t);

    const v = pickVoice(langTag);
    if(v) u.voice = v;

    u.lang = langTag || "de-DE";

    u.onstart = () => { TTS.speaking = true; TTS.currentKey = key; };
    u.onend = () => { TTS.speaking = false; if(TTS.currentKey === key) TTS.currentKey = ""; };
    u.onerror = () => { TTS.speaking = false; if(TTS.currentKey === key) TTS.currentKey = ""; };

    window.speechSynthesis.speak(u);
  }

  function deLang(){ return "de-DE"; }

  detail.addEventListener("click", (e)=>{
    const btn = e.target.closest(".speakBtn");
    if(!btn) return;
    e.preventDefault();
    e.stopPropagation();

    const say = btn.getAttribute("data-say") || "";
    const lang = btn.getAttribute("data-lang") || "";
    speakText(say, lang);
  });

  // -------------------------
  // plural logic
  // -------------------------
  function parsePluralFieldNew(pluralField){
    const raw = (pluralField ?? "").toString().trim();
    if(!raw) return { raw:"", kind:"none" };
    if(raw === "-" || raw === "‚Äì" || raw === "‚Äî") return { raw, kind:"same" };

    const low = raw.toLowerCase();
    if(low === "samosg") return { raw, kind:"no_plural" };

    const mDip = raw.match(/^([√§√Ñ])([uU])\-?(e|er|en|n|s)$/);
    if(mDip){
      const first = mDip[1];
      const second = mDip[2];
      const diph = (first === "√Ñ" ? "√Ñ" : "√§") + (second === "U" ? "U" : "u");
      return { raw, kind:"umlaut_diphthong", diphthong: diph, suffix: mDip[3].toLowerCase() };
    }

    const mU = raw.match(/^([√§√∂√º√Ñ√ñ√ú])\-?(e|er|en|n|s)$/);
    if(mU){
      return { raw, kind:"umlaut_suffix", umlautChar:mU[1], suffix:mU[2].toLowerCase() };
    }

    if(/^(e|er|en|n|s)$/i.test(raw)){
      return { raw, kind:"suffix", suffix: raw.toLowerCase() };
    }

    return { raw, kind:"append", append: raw };
  }

  function applyUmlautToLastComponent(word, umlautChar){
    const hw = (word ?? "").toString();
    if(!hw) return hw;

    const map = { "√§":"a", "√∂":"o", "√º":"u", "√Ñ":"A", "√ñ":"O", "√ú":"U" };
    const base = map[umlautChar];
    if(!base) return hw;

    const dashIdx = hw.lastIndexOf("-");
    const prefix = dashIdx >= 0 ? hw.slice(0, dashIdx + 1) : "";
    const last = dashIdx >= 0 ? hw.slice(dashIdx + 1) : hw;

    const idx = last.lastIndexOf(base);
    if(idx < 0) return hw;

    const newLast = last.slice(0, idx) + umlautChar + last.slice(idx + 1);
    return prefix + newLast;
  }

  function applyAeuToLastComponent(word){
    const hw = (word ?? "").toString();
    if(!hw) return hw;

    const dashIdx = hw.lastIndexOf("-");
    const prefix = dashIdx >= 0 ? hw.slice(0, dashIdx + 1) : "";
    const last = dashIdx >= 0 ? hw.slice(dashIdx + 1) : hw;

    const idxLower = last.lastIndexOf("au");
    const idxUpper = last.lastIndexOf("Au");

    let idx = -1;
    let from = "";
    let to = "";

    if(idxLower >= 0 && idxUpper >= 0){
      if(idxLower > idxUpper){ idx = idxLower; from="au"; to="√§u"; }
      else { idx = idxUpper; from="Au"; to="√Ñu"; }
    }else if(idxLower >= 0){
      idx = idxLower; from="au"; to="√§u";
    }else if(idxUpper >= 0){
      idx = idxUpper; from="Au"; to="√Ñu";
    }else{
      return hw;
    }

    const newLast = last.slice(0, idx) + to + last.slice(idx + from.length);
    return prefix + newLast;
  }

  function buildPluralFormNew(headword, pluralField){
    const hw = (headword ?? "").toString().trim();
    if(!hw) return "";

    const info = parsePluralFieldNew(pluralField);

    if(info.kind === "none") return "";
    if(info.kind === "no_plural") return "";
    if(info.kind === "same") return hw;

    if(info.kind === "suffix") return hw + info.suffix;
    if(info.kind === "umlaut_suffix") return applyUmlautToLastComponent(hw, info.umlautChar) + info.suffix;
    if(info.kind === "umlaut_diphthong") return applyAeuToLastComponent(hw) + info.suffix;
    if(info.kind === "append") return hw + info.append;

    return "";
  }

  function wrapSuffix(fullWord, suffix){
    const s = (suffix ?? "").toString();
    if(!s) return escapeHtml(fullWord);
    const base = fullWord.slice(0, fullWord.length - s.length);
    return `${escapeHtml(base)}<span class="plHi">${escapeHtml(s)}</span>`;
  }

  function wrapRange(word, start, len){
    const w = (word ?? "").toString();
    if(start == null || len == null || start < 0 || len <= 0) return escapeHtml(w);
    const a = w.slice(0, start);
    const b = w.slice(start, start + len);
    const c = w.slice(start + len);
    return `${escapeHtml(a)}<span class="plHi">${escapeHtml(b)}</span>${escapeHtml(c)}`;
  }

  function applyUmlautToLastComponentMarked(word, umlautChar){
    const hw = (word ?? "").toString();
    if(!hw) return { word: hw, hiStart: -1, hiLen: 0 };

    const map = { "√§":"a", "√∂":"o", "√º":"u", "√Ñ":"A", "√ñ":"O", "√ú":"U" };
    const base = map[umlautChar];
    if(!base) return { word: hw, hiStart: -1, hiLen: 0 };

    const dashIdx = hw.lastIndexOf("-");
    const prefix = dashIdx >= 0 ? hw.slice(0, dashIdx + 1) : "";
    const last = dashIdx >= 0 ? hw.slice(dashIdx + 1) : hw;

    const idxBase = last.lastIndexOf(base);
    if(idxBase >= 0){
      const newLast = last.slice(0, idxBase) + umlautChar + last.slice(idxBase + 1);
      const newWord = prefix + newLast;
      const absStart = prefix.length + idxBase;
      return { word: newWord, hiStart: absStart, hiLen: 1 };
    }

    const idxU = last.lastIndexOf(umlautChar);
    if(idxU >= 0){
      const absStart = prefix.length + idxU;
      return { word: hw, hiStart: absStart, hiLen: 1 };
    }

    return { word: hw, hiStart: -1, hiLen: 0 };
  }

  function applyAeuToLastComponentMarked(word){
    const hw = (word ?? "").toString();
    if(!hw) return { word: hw, hiStart: -1, hiLen: 0 };

    const dashIdx = hw.lastIndexOf("-");
    const prefix = dashIdx >= 0 ? hw.slice(0, dashIdx + 1) : "";
    const last = dashIdx >= 0 ? hw.slice(dashIdx + 1) : hw;

    const idxLower = last.lastIndexOf("au");
    const idxUpper = last.lastIndexOf("Au");

    if(idxLower >= 0 || idxUpper >= 0){
      let idx = -1, from = "", to = "";
      if(idxLower >= 0 && idxUpper >= 0){
        if(idxLower > idxUpper){ idx = idxLower; from="au"; to="√§u"; }
        else { idx = idxUpper; from="Au"; to="√Ñu"; }
      }else if(idxLower >= 0){
        idx = idxLower; from="au"; to="√§u";
      }else{
        idx = idxUpper; from="Au"; to="√Ñu";
      }

      const newLast = last.slice(0, idx) + to + last.slice(idx + from.length);
      const newWord = prefix + newLast;
      const absStart = prefix.length + idx;
      return { word: newWord, hiStart: absStart, hiLen: 2 };
    }

    const idxAeu = Math.max(last.lastIndexOf("√§u"), last.lastIndexOf("√Ñu"));
    if(idxAeu >= 0){
      const absStart = prefix.length + idxAeu;
      return { word: hw, hiStart: absStart, hiLen: 2 };
    }

    return { word: hw, hiStart: -1, hiLen: 0 };
  }

  function buildPluralHtml(headword, pluralField){
    const hw = (headword ?? "").toString().trim();
    if(!hw) return "";

    const info = parsePluralFieldNew(pluralField);
    if(info.kind === "none" || info.kind === "no_plural") return "";

    if(info.kind === "same") return escapeHtml(hw);

    if(info.kind === "suffix"){
      const full = hw + info.suffix;
      return wrapSuffix(full, info.suffix);
    }

    if(info.kind === "append"){
      const full = hw + info.append;
      return wrapSuffix(full, info.append);
    }

    if(info.kind === "umlaut_suffix"){
      const r = applyUmlautToLastComponentMarked(hw, info.umlautChar);
      const wordHtml = wrapRange(r.word, r.hiStart, r.hiLen);
      const suffixHtml = `<span class="plHi">${escapeHtml(info.suffix)}</span>`;
      return `${wordHtml}${suffixHtml}`;
    }

    if(info.kind === "umlaut_diphthong"){
      const r = applyAeuToLastComponentMarked(hw);
      const wordHtml = wrapRange(r.word, r.hiStart, r.hiLen);
      const suffixHtml = `<span class="plHi">${escapeHtml(info.suffix)}</span>`;
      return `${wordHtml}${suffixHtml}`;
    }

    const full = buildPluralFormNew(hw, pluralField);
    if(!full) return "";
    return escapeHtml(full);
  }

  // German plural tag: ONLY for DE_SR (German nouns)
  function renderPluralTag(item){
    if(dir !== "DE_SR") return "";
    const pos = (item?.pos ?? "").toString().trim().toLowerCase();
    const plRaw = (item?.plural ?? "").toString().trim();
    if(pos !== "noun" || !plRaw) return "";

    const info = parsePluralFieldNew(plRaw);
    if(info.kind === "no_plural") return "";

    const htmlPlural = buildPluralHtml(item.headword, plRaw);
    if(!htmlPlural) return "";

    const pluralText = buildPluralFormNew(item.headword, plRaw) || "";

    return `<span class="plTag">
      <span>Pl: ${htmlPlural}</span>
      <button class="speakBtn" type="button" title="Aussprache" aria-label="Plural sprechen"
        data-lang="${escapeHtml(deLang())}" data-say="${escapeHtml(pluralText)}">üîä</button>
    </span>`;
  }

  function headwordGenderClass(item){
    const pos = (item?.pos ?? "").toString().trim().toLowerCase();
    if(pos !== "noun") return "";
    const g = (item?.gender ?? "").toString().trim().toLowerCase();
    return (g === "der" || g === "die" || g === "das") ? g : "";
  }

  function fitHeadword(){
    const el = detail.querySelector(".word");
    if(!el) return;

    el.style.whiteSpace = "nowrap";
    el.style.overflowWrap = "";
    el.style.wordBreak = "";
    el.style.fontSize = "40px";

    const min = 24;
    let size = 40;
    let guard = 0;

    while(el.scrollWidth > el.clientWidth && size > min && guard < 80){
      size -= 1;
      el.style.fontSize = size + "px";
      guard++;
    }

    if(el.scrollWidth > el.clientWidth){
      el.style.whiteSpace = "normal";
      el.style.overflowWrap = "anywhere";
      el.style.wordBreak = "break-word";
      el.style.fontSize = Math.max(size, min) + "px";
    }
  }

  function renderSense(lines, quick){
    if(!lines || !lines.length) return "";

    const nonEmpty = lines.map(x=>x.trim()).filter(Boolean);
    if(nonEmpty.length === 1 && normalizeCmp(nonEmpty[0]) === normalizeCmp(quick)) return "";

    let idx = 0;
    let heading = "";
    if(nonEmpty.length >= 2 && !lineIsLang(nonEmpty[0]) && lineIsLang(nonEmpty[1])){
      if(normalizeCmp(nonEmpty[0]) !== normalizeCmp(quick)){
        heading = nonEmpty[0];
      }
      idx = 1;
    }

    const blocks = [];

    for(let i=idx;i<nonEmpty.length;i++){
      const line = nonEmpty[i];

      const m = line.match(/^\s*(DE|SR)\s*:\s*(.*)$/i);
      if (m) {
        const lang = m[1].toLowerCase();
        const txt = (m[2] || "").trim();

        if (lang === "de") {
          const md = txt.match(/^(.*?)(?:\s*[‚Äî‚Äì]\s*SR\s*:\s*)(.+)$/i);
          if (md) {
            const left = (md[1] || "").trim();
            const right = (md[2] || "").trim();
            if (left) blocks.push({ type: "pair", lang: "de", txt: left });
            if (right) blocks.push({ type: "pair", lang: "sr", txt: right });
            continue;
          }

          const ms = txt.match(/^(.*?)(?:\s*\/\s*SR\s*:\s*)(.+)$/i);
          if (ms) {
            const left = (ms[1] || "").trim();
            const right = (ms[2] || "").trim();
            if (left) blocks.push({ type: "pair", lang: "de", txt: left });
            if (right) blocks.push({ type: "pair", lang: "sr", txt: right });
            continue;
          }
        }

        blocks.push({ type:"pair", lang, txt });
        continue;
      }

      const p = splitInlinePair(line);
      if(p){
        blocks.push({ type:"pair", lang:"de", txt: p.de });
        blocks.push({ type:"pair", lang:"sr", txt: p.sr });
        continue;
      }

      blocks.push({ type:"plain", txt: line });
    }

    const headHtml = heading ? `<div class="head">${escapeHtml(heading)}</div>` : "";

    const inner = blocks.map(b=>{
      if(b.type==="pair"){
        const langTag = b.lang;
        const speak = (langTag === "de")
          ? `<button class="speakBtn" type="button" title="Aussprache" aria-label="Beispiel sprechen"
              data-lang="${escapeHtml(deLang())}" data-say="${escapeHtml(b.txt)}">üîä</button>`
          : "";

        return `<div class="pair">
          <div class="pairMain">
            <span class="langTag ${langTag}">${langBadgeHtml(langTag)}</span>
            <span class="langTxt">${escapeHtml(b.txt).replace(/\n/g,"<br>")}</span>
          </div>
          ${speak}
        </div>`;
      }
      return `<div class="plain">${escapeHtml(b.txt).replace(/\n/g,"<br>")}</div>`;
    }).join("");

    return `<div class="sense">${headHtml}${inner}</div>`;
  }

  function renderExplanationRich(rawText, item, quick){
    const baseLines = normalizeRawLines(rawText ?? "");
    const senses = splitIntoSenses(baseLines);

    const sensesHtml = senses.map(sLines=>{
      const s2 = dropLeadingQuickDuplicate(sLines, quick);
      return renderSense(s2, quick);
    }).filter(Boolean).join("");

    return `<div class="explain">${sensesHtml || `<div class="plain">‚Äî</div>`}</div>`;
  }

  const POS_MAP_SR = {
    "noun": "imenica",
    "verb": "glagol",
    "adj":  "pridev",
    "adv":  "prilog",
    "prep": "predlog",
    "pron": "zamenica",
    "num":  "broj",
    "conj": "veznik",
    "intj": "uzvik",
    "part": "reƒçca",
    "prefix": "prefiks"
  };

  function toSrPos(pos){
    const p = (pos || "").toString().trim().toLowerCase();
    return POS_MAP_SR[p] || (pos || "");
  }

  function firstTopic(topics){
    if(!topics) return "";
    if(Array.isArray(topics) && topics.length) return topics[0];
    return String(topics);
  }

  function renderMetaHtml(item){
    const posSr = toSrPos(item.pos);
    const gender = (item.gender || "").toString().trim().toLowerCase();

    const genderHtml = (gender === "der" || gender === "die" || gender === "das")
      ? ` ‚Ä¢ <span class="art ${gender}">${escapeHtml(gender)}</span>`
      : (gender ? ` ‚Ä¢ ${escapeHtml(gender)}` : "");

    const lvl = item.level ? ` | ${escapeHtml(item.level)}` : "";
    const t0 = firstTopic(item.topics);
    const t = t0 ? ` | tema: ${escapeHtml(t0)}` : "";

    return `${escapeHtml(posSr)}${genderHtml}${lvl}${t}`;
  }

  function renderDetail(item){
    if(!item){
      detail.innerHTML = `
        <div class="word">‚Äî</div>
        <div class="meta">Kucaj za pretragu (${dir==="SR_DE" ? "SR‚ÜíDE" : "DE‚ÜíSR"})</div>
        <div class="wordUnderline"></div>
        <div class="quick">‚Äî</div>
        <div class="explain"><div class="plain">raw_clean ƒáe se prikazati ovde.</div></div>`;
      return;
    }

    const hasRawClean = !!((item?.raw_clean ?? "").toString().trim());
    const quick = hasRawClean ? "" : getQuickGloss(item);

    let explanation = getExplanationText(item) || "‚Äî";
    if(hasRawClean){
      explanation = stripRawCleanHeaderLine(explanation, item);
    }

    let lines = normalizeRawLines(explanation);
    lines = dropLeadingQuickDuplicate(lines, quick);
    explanation = lines.join("\n");

    const pluralHtml = renderPluralTag(item) || `<span class="plTag plEmpty">Pl: ‚Äî</span>`;
    const hwCls = headwordGenderClass(item);

    const headwordSpeak = (dir === "DE_SR")
      ? `<button class="speakBtn" type="button" title="Aussprache" aria-label="Wort sprechen"
          data-lang="${escapeHtml(deLang())}" data-say="${escapeHtml(item.headword)}">üîä</button>`
      : "";

    detail.innerHTML = `
      ${renderImageHtml(item)}
      <div class="wordRow">
        <div class="wordLine">
          <div class="word ${hwCls}">${escapeHtml(item.headword)}</div>
          ${headwordSpeak}
        </div>
        ${pluralHtml}
      </div>
      <div class="meta">${renderMetaHtml(item)}</div>
      <div class="wordUnderline"></div>
      ${hasRawClean ? "" : `<div class="quick">${escapeHtml(quick || "‚Äî")}</div>`}
      ${renderExplanationRich(explanation, item, quick)}
    `;

    requestAnimationFrame(fitHeadword);
  }

  function renderList(){
    list.innerHTML = "";
    results.forEach((item, idx) => {
      const li = document.createElement("li");
      li.className = "suggestItem";
      li.dataset.active = (idx===active) ? "true" : "false";
      li.innerHTML = `
        <div class="hw">${escapeHtml(item.headword)}</div>
        <div class="tr">${escapeHtml(normalizeGloss(item.main_gloss || ""))}</div>
      `;
      li.addEventListener("mouseenter", ()=>{ active=idx; renderList(); renderDetail(results[active]); });
      li.addEventListener("click", ()=>{ active=idx; renderList(); renderDetail(results[active]); });
      list.appendChild(li);
    });
    renderDetail(results[active]);
  }

  async function fetchJson(url){
    const r = await fetch(url, { headers: { "Accept": "application/json" }});
    if(!r.ok){
      const t = await r.text().catch(()=> "");
      throw new Error(`HTTP ${r.status} ${r.statusText}${t ? " ‚Äî " + t : ""}`);
    }
    return r.json();
  }

  async function search(){
    const term = q.value.trim();
    errBox.style.display = "none";
    loading.style.display = "block";

    try{
      const params = new URLSearchParams({ direction: dir, q: term, limit: "20" });
      const data = await fetchJson(`/api/dict/search?${params.toString()}`);

      results = Array.isArray(data) ? data : (data?.rows || []);
      active = 0;
      renderList();
    }catch(e){
      results = [];
      active = 0;
      list.innerHTML = "";
      renderDetail(null);
      errBox.textContent = String(e.message || e);
      errBox.style.display = "block";
    }finally{
      loading.style.display = "none";
    }
  }

  q.addEventListener("input", ()=>{
    clearTimeout(window.__t);
    window.__t = setTimeout(search, 120);
  });

  q.addEventListener("keydown", (e)=>{
    if(e.key==="ArrowDown"){ e.preventDefault(); if(results.length){ active=Math.min(active+1, results.length-1); renderList(); } }
    else if(e.key==="ArrowUp"){ e.preventDefault(); if(results.length){ active=Math.max(active-1, 0); renderList(); } }
    else if(e.key==="Enter"){ e.preventDefault(); renderDetail(results[active]); }
    else if(e.key==="Escape"){ e.preventDefault(); q.value=""; q.focus(); search(); }
  });

  window.addEventListener("resize", ()=> requestAnimationFrame(fitHeadword));

  renderDetail(null);
  q.focus();
  search();
</script>
</body>
</html>
